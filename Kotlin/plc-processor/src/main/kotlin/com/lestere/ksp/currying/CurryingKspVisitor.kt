package com.lestere.ksp.currying

import com.google.devtools.ksp.isConstructor
import com.google.devtools.ksp.processing.Dependencies
import com.google.devtools.ksp.processing.SymbolProcessorEnvironment
import com.google.devtools.ksp.symbol.*
import com.lestere.ksp.utils.ResourceReader
import com.lestere.ksp.utils.capitalizeFirstChar
import com.lestere.ksp.utils.filterAnnotations
import com.lestere.ksp.utils.loadTemplate
import com.lestere.ksp.utils.writeText
import kotlinx.datetime.Clock
import kotlinx.datetime.TimeZone
import kotlinx.datetime.toLocalDateTime

/**
 * A Kotlin Symbol Processor (KSP) visitor for generating curried function implementations from annotated functions.
 * This class processes functions marked with the `@Currying` annotation, validates their modifiers and parameters,
 * and generates Kotlin code that transforms multi-parameter functions into nested lambda chains (curried functions).
 *
 * ### Core Responsibilities:
 * 1. **Annotation Processing**:
 *    - Detect functions annotated with `@Currying`.
 *    - Extract configuration parameters from the annotation (e.g., `packageName`, `format`).
 *
 * 2. **Validation**:
 *    - Ensure functions do not contain unsupported modifiers (e.g., `abstract`, `suspend`, `inline`).
 *    - Verify functions have at least 2 parameters (required for currying).
 *    - Resolve and validate function return types.
 *
 * 3. **Code Generation**:
 *    - Generate nested lambda implementations for curried functions.
 *    - Create type aliases and JVM-specific names to handle type erasure and overloading.
 *    - Output generated code to new Kotlin files with proper package structure and headers.
 *
 * ### Architecture Overview:
 * - **Symbol Processing**: Leverages KSP's `KSVisitorVoid` to traverse function declarations.
 * - **Configuration**: Reads annotation parameters to customize generated code (qualified vs. typealias format).
 * - **Template System**: Uses string templates for code structure (e.g., `FUNCTION_BODY_TEMPLATE`),
 *   ensuring consistency and maintainability.
 * - **Error Handling**: Throws `CurryingExceptions` for validation failures, logged via `SymbolProcessorEnvironment`.
 *
 * ### Usage Example:
 * ```kotlin
 * // Original function
 * @Currying
 * fun sum(a: Int, b: Int, c: Int): Int = a + b + c
 *
 * // Generated code (simplified):
 * package com.example
 *
 * import kotlin.reflect.KFunction3
 *
 * @JvmName("function.formula.currying.sum$0a1b2c")
 * fun KFunction3<Int, Int, Int, Int>.currying(): (Int) -> (Int) -> (Int) -> Int = { a -> { b -> { c -> this(a, b, c) } } }
 * ```
 *
 * ### Design Decisions:
 * - **JVM Name Generation**: Uses hashing of parameter types to create unique names, avoiding collisions due to type erasure.
 * - **Type Aliases**: Provides optional type alias generation for cleaner syntax in generated code.
 * - **Nesting Handling**: Traverses parent declarations (classes/interfaces) to build correct package paths and qualified names.
 *
 * ### Extensibility Points:
 * 1. **Modifier Support**: Extend `UNSUPPORTED_FUNCTION_MODIFIER` to add/remove restricted modifiers.
 * 2. **Template Customization**: Modify template strings (e.g., `FUNCTION_BODY_TEMPLATE`) to change code style.
 * 3. **Error Reporting**: Subclass `CurryingExceptions` to provide richer error messages with location information.
 *
 * @property environment The KSP SymbolProcessorEnvironment for logging, file I/O, and dependency management.
 * @see KSVisitorVoid
 * @see Currying
 * @see CurryingExceptions
 * @author LesterE (159.759dcsvdu@gmail.com)
 * @since 2025-06-06
 */
internal class CurryingKspVisitor(private val environment: SymbolProcessorEnvironment) : KSVisitorVoid() {
    private companion object {
        /**
         * Template for generating nested lambda expressions in curried function implementations.
         *
         * This template is used to build the body of curried functions with proper indentation and structure.
         * It supports three placeholders:
         * - `{{spacer}}`: Indentation spacing for the current lambda level
         * - `{{tail}}`: Parameter list for the current lambda
         * - `{{content}}`: Nested lambda body or final function call
         *
         * Example usage for a curried function with two parameters:
         * ```kotlin
         * { x: Int ->
         *     { y: Int ->
         *         this.invoke(x, y)
         *     }
         * }
         * ```
         *
         * @see processFunctionBody
         */
        const val FUNCTION_BODY_TEMPLATE = "{{spacer}}{ {{tail}}\n{{content}}\n{{spacer}}}"

        /**
         * Prefix for JVM method names generated by the currying extension functions.
         *
         * Used to create unique, human-readable JVM method names for curried functions.
         * The full JVM name format is:
         * `JVM_NAME_PREFIX + originalFunctionName + "$" + parameterTypesHash`
         *
         * Example generated JVM name:
         * ```kotlin
         * @JvmName("function\$formula\$currying\$sumOfThreeInts")
         * fun KFunction3<Int, Int, Int, Int>.currying(...): ...
         * ```
         *
         * This helps in debugging and reflection scenarios by maintaining meaningful method names.
         */
        const val JVM_NAME_PREFIX = "function.formula.currying."

        /**
         * Name of the generated currying function.
         * This is the function that will be added to the KFunction extensions (e.g., KFunction2.currying()).
         */
        const val CURRYING_FUNCTION_NAME = "currying"

        /**
         * Template for the generated file name.
         * - {{qualified_name}}: Will be replaced with the qualified name of the original function.
         * Example output: "com/example/MyClassMyFunctionFunctionFormulaCurrying.kt"
         */
        const val FILENAME_SUFFIX = "{{qualified_name}}FunctionFormulaCurrying"

        /**
         * Template for JVM-specific method names to avoid type erasure conflicts.
         * - {{capitalize_function_name}}: Original function name with the first letter capitalized.
         * Example output: "KFunctionJvmNameForMyFunction"
         */
        const val JVM_NAME_SUFFIX = "KFunctionJvmNameFor{{capitalize_function_name}}"

        /**
         * Template for type aliases representing KFunction types.
         * - {{capitalize_function_name}}: Original function name with the first letter capitalized.
         * Example output: "typealias KFunctionForMyFunction = (Int, String) -> Unit"
         */
        const val TYPEALIAS_FORMAT = "KFunctionFor{{capitalize_function_name}}"

        /**
         * Template for type aliases representing curried lambda types.
         * - {{capitalize_function_name}}: Original function name with the first letter capitalized.
         * Example output: "typealias KFunctionForMyFunctionLambda = (Int) -> (String) -> Unit"
         */
        const val TYPEALIAS_LAMBDA_FORMAT = "KFunctionFor{{capitalize_function_name}}Lambda"

        /**
         * Contains a list of function modifiers that are not supported by the code generator.
         * Functions with these modifiers will cause code generation to fail.
         * Currently unsupported modifiers include:
         * - [Modifier.ABSTRACT]: Abstract functions lack implementations and cannot be invoked directly.
         * - [Modifier.SUSPEND]: Suspending functions require coroutine context, which is not handled by the current generator.
         * - [Modifier.INLINE]: Inline functions are expanded at compile-time, conflicting with runtime code generation.
         */
        val UNSUPPORTED_FUNCTION_MODIFIER = listOf(
            Modifier.ABSTRACT,
            Modifier.SUSPEND,
            Modifier.INLINE
        )

        /**
         * Processes a list of type strings representing a function trail and converts it into a nested function type notation.
         *
         * Transforms a list of types into a curried function type representation. For example,
         * - Input: ["A", "B", "C", "D"]
         * - Output: "((A) -> (B) -> (C) -> D)"
         *
         * @param source List of type strings where the last element is the return type and preceding elements are parameter types.
         * @return A string representing the curried function type with proper nesting.
         * @throws NoSuchElementException if the input list is empty.
         */
        private fun processFunctionTrailType(source: List<KSTypeDefinition>, qualified: Boolean = true): String {
            val arguments = source.take(source.size - 1)
            val trailing = source.last()
            return arguments
                .takeLast(arguments.size - 1)
                .reversed()
                .fold(trailing.second.typeQualifiedName(qualified)) { acc, (name, type) ->
                    "(($name: ${type.typeQualifiedName(qualified)}) -> $acc)"
                }
        }

        /**
         * Recursively resolves the fully qualified name of a Kotlin type reference, including generic type arguments.
         *
         * Handles the following scenarios:
         * - Basic types (e.g., `java.lang.String`)
         * - Generic types (e.g., `kotlin.collections.List<java.lang.String>`)
         * - Generic parameters with variance annotations (e.g., `kotlin.reflect.KFunction<in java.lang.String>`)
         * - Star projections (e.g., `kotlin.collections.Map<*, *>`)
         *
         * @return The resolved fully qualified type name formatted as:
         *         - Basic types: `package.Name`
         *         - Generic types: `package.Name<typeArg1, typeArg2>`
         *         - With variance: `package.Name<in typeArg1, out typeArg2>`
         *         - Original string representation if resolution fails
         */
        private fun KSTypeReference.typeQualifiedName(qualified: Boolean = true): String {
            val resolvedType = resolve()
            val declaration = resolvedType.declaration

            // Get basic type qualified name
            val baseName = if (qualified) {
                declaration.qualifiedName?.asString() ?: return toString()
            } else {
                declaration.simpleName.getShortName()
            }

            // Collect generic parameter information
            val typeArguments = resolvedType.arguments.joinToString(
                separator = ", ",
                prefix = "<",
                postfix = ">"
            ) { argument ->
                when (argument.variance) {
                    Variance.INVARIANT -> argument.type?.typeQualifiedName(qualified) ?: "*"
                    Variance.COVARIANT -> "+${argument.type?.typeQualifiedName(qualified) ?: "*"}"
                    Variance.CONTRAVARIANT -> "-${argument.type?.typeQualifiedName(qualified) ?: "*"}"
                    else -> "*" // * as any shadow
                }
            }

            // The complete type name of the common type with splicing
            return if (typeArguments == "<>") baseName else "$baseName$typeArguments"
        }

        /**
         * Generates a string representation of a [KSTypeDefinition] for code generation.
         * Constructs a parameter-like string with name and type, formatted as:
         * - Qualified mode: "name: package.ClassName<TypeArgs>" (uses fully qualified type names)
         * - Unqualified mode: "name: ClassName" (uses simple type names from resolved declarations)
         *
         * @param qualified Whether to use qualified type names (default: true).
         * @return Formatted string combining the parameter name and type.
         * @see KSTypeReference.typeQualifiedName for qualified type name resolution.
         * @see KSTypeReference.resolve for unqualified type declaration resolution.
         */
        private fun KSTypeDefinition.typeDefinition(qualified: Boolean = true): String = if (qualified) {
            "$first: ${second.typeQualifiedName()}"
        } else {
            "$first: ${second.resolve().declaration.simpleName.asString()}"
        }

        /**
         * Generates a file header comment for generated code, including
         * 1. A commit template from resources
         * 2. Replacement of placeholders with:
         *    - Qualified function/package name
         *    - Current timestamp (local system time)
         *
         * @param packageName The qualified package name for the generated file.
         * @return Formatted header comment string with populated placeholders.
         * @throws java.io.IOException if the template file cannot be read (handled by ResourceReader).
         * @see ResourceReader.readText for file reading implementation.
         * @see Clock.System.now() for timestamp generation.
         */
        private fun generateFileHeaderCommit(packageName: String): String = ResourceReader
            .readText("commit/CurryingGenerated.txt")
            .loadTemplate("qualified_function_name", packageName)
            .loadTemplate(
                "timestamp", Clock.System.now()
                    .toLocalDateTime(TimeZone.currentSystemDefault())
                    .toString()
            )

        /**
         * Converts a camelCase or PascalCase string to snake_case format in uppercase.
         *
         * Example transformations:
         * - "someText" -> "SOME_TEXT"
         * - "HTTPRequest" -> "HTTP_REQUEST"
         * - "IDGenerator" -> "ID_GENERATOR"
         *
         * @return The transformed string in uppercase snake_case.
         */
        private fun String.uppercaseUpperWithUnderline(): String = this
            .replace(Regex("(?<=[a-z])([A-Z])"), "_$1")
            .lowercase()
    }

    /**
     * Entry point for processing function declarations annotated with `@Currying`.
     * Orchestrates validation, configuration extraction, signature processing, and code generation.
     *
     * ### Processing Flow:
     * 1. **Annotation Extraction**:
     *    - Reads `packageName` and `format` from the `@Currying` annotation.
     *    - Validates annotation parameters (e.g., ensures non-empty package names).
     *
     * 2. **Validation**:
     *    - Calls `modifierValidate()` to check for unsupported modifiers.
     *    - Throws `CurryingExceptions` for parameter count or return type issues.
     *
     * 3. **Code Generation**:
     *    - Generates package information using `processSpecificPackage()`.
     *    - Builds function signature with `processFunctionSignature()`.
     *    - Writes output to a new Kotlin file using `environment.codeGenerator`.
     *
     * ### Error Handling:
     * - Catches `CurryingExceptions` and logs errors with context (function location).
     * - Logs success messages with generated file details.
     *
     * @param function The `KSFunctionDeclaration` to process.
     * @param data Unused parameter (required by `KSVisitorVoid` interface).
     * @throws CurryingExceptions For validation failures (modifiers, parameter count, return type).
     * @see processSpecificPackage
     * @see processFunctionSignature
     */
    override fun visitFunctionDeclaration(function: KSFunctionDeclaration, data: Unit) = try {
        // FIXME: Dose not support function with modifier suspend and inline, implement already in time!!
        function.modifierValidate()

        var specifiedPackageName: String? = null
        var specifiedFormat = CurryingFormat.QUALIFIED

        function.annotations
            .filterAnnotations(Currying::class)
            .forEach { annotation ->
                annotation.arguments.forEach { argument ->
                    when (argument.name?.asString()) {
                        "packageName" -> {
                            val value = argument.value as? String
                            specifiedPackageName = if (value.isNullOrEmpty()) null else value
                        }

                        "format" -> runCatching {
                            val name = argument.value.toString().split(".").lastOrNull()
                            name?.let { specifiedFormat = CurryingFormat.valueOf(name) }
                        }
                    }
                }
            }

        // Analysis package information
        val packageInfo = processSpecificPackage(function, specifiedPackageName)
        val packageName = packageInfo.packageName

        // Process generated file information
        val simpleName = packageInfo.simpleName
        val filePrefix = simpleName.capitalizeFirstChar()
        val fileName = FILENAME_SUFFIX.loadTemplate("qualified_name", filePrefix)

        val functionSignature = processFunctionSignature(function, packageInfo)

        // Generate .kt file
        val dependencies = Dependencies(true, function.containingFile!!)
        val stream = environment.codeGenerator.createNewFile(dependencies, packageName, fileName)

        var content = ""
        content += generateFileHeaderCommit(packageInfo.fullOriginPackageName)
        content += "package $packageName\n\n"

        when (specifiedFormat) {
            CurryingFormat.QUALIFIED -> {
                content += "@JvmName(name = \"${functionSignature.jvmName}\")\n"
                content += "${functionSignature.assembleQualifiedFunctionBody()} = "
            }

            CurryingFormat.TYPEALIAS -> {
                content += "import " + functionSignature.arguments.joinToMultiLineImport()
                content += "\nimport ${functionSignature.extensionFor.getQualifierNameWithoutGenerics()}\n\n"

                val jvmVariable = JVM_NAME_SUFFIX.loadTemplate("capitalize_function_name", filePrefix)
                val targetTypealias = TYPEALIAS_FORMAT.loadTemplate("capitalize_function_name", filePrefix)
                val callbackTypealias =
                    TYPEALIAS_LAMBDA_FORMAT.loadTemplate("capitalize_function_name", filePrefix)

                content += "private const val $jvmVariable = \"${functionSignature.jvmName}\"\n"

                content += "\n"

                content += "private typealias $targetTypealias = ${functionSignature.getKFunction(false)}\n"
                content += "private typealias $callbackTypealias = ${functionSignature.getReturnTypeString(false)}\n"

                content += "\n"

                content += "@JvmName(name = $jvmVariable)\n"
                content += "${functionSignature.assembleTypeAliasedBody(targetTypealias, callbackTypealias)} = "
            }
        }

        val isQualified = specifiedFormat == CurryingFormat.QUALIFIED
        content += processFunctionBody(functionSignature.returnTypeChain, isQualified)
        content += "\n"

        // Write kotlin codes
        stream.writeText(content)

        environment.logger.info("${packageName}.$simpleName generated.", function)
    } catch (e: CurryingExceptions.UnsupportedConstructor) {
        /*@Mark: Excepted：
         *  [CurryingExceptions.LessThanTwoParametersFunction]
         *  [CurryingExceptions.UnsupportedModifierWithFunction]
         *  [CurryingExceptions.UnresolvedFunctionReturnType]
         *  [CurryingExceptions.UnresolvedFunctionOriginPackage]
         *  [CurryingExceptions.UnsupportedConstructor]
         */
        environment.logger.exception(e)
    }

    /**
     * Processes the package information for a curried function, considering both specified and inferred packages.
     * Constructs the full package name by combining:
     * 1. The explicitly specified package (if provided)
     * 2. The function containing file package (if no explicit package is specified)
     * 3. The qualified names of parent declarations (converted to uppercase with underscores)
     *
     * Example:
     * For a function in com.example.MyClass#myFunction with no specified package,
     * this might return a PackageInfo with:
     * - maintain: "com.example.MY_CLASS"
     * - simpleName: "myFunction"
     *
     * @param function The function to process package information for.
     * @param specifiedPackage Optional explicitly specified package name.
     * @return A [PackageInfo] containing the constructed package name components.
     * @throws CurryingExceptions.UnresolvedFunctionOriginPackage If the function has no containing file and no package is specified.
     */
    @Throws(CurryingExceptions::class)
    private fun processSpecificPackage(function: KSFunctionDeclaration, specifiedPackage: String?): PackageInfo {
        val simpleName = function.simpleName.asString()

        // Base package name
        val originPackage = function.containingFile?.packageName?.asString()
            ?: throw CurryingExceptions.UnresolvedFunctionOriginPackage(simpleName)

        // Destination package name
        val packageName = specifiedPackage ?: originPackage

        // Find the scope between the file and the target and join between origin package name and contains
        val parentPackageSeparator = function.directParentDeclarations()

        return PackageInfo(packageName, parentPackageSeparator, simpleName, originPackage)
    }

    /**
     * Processes the function signature to generate necessary information for currying transformation.
     * Constructs a [FunctionSignatureInfo] containing:
     * 1. Full qualified name with package and parent declarations
     * 2. KFunction type signature with all parameters and return type
     * 3. JVM-specific name to handle type erasure and method overloading
     *
     * @param function The function to process signature for.
     * @param packageInfo The preprocessed package information for the function.
     * @return A [FunctionSignatureInfo] containing parsed signature components.
     * @throws CurryingExceptions.LessThanTwoParametersFunction If the function has fewer than 2 parameters.
     * @throws CurryingExceptions.UnresolvedFunctionReturnType If the function's return type cannot be resolved.
     */
    private fun processFunctionSignature(
        function: KSFunctionDeclaration,
        packageInfo: PackageInfo
    ): FunctionSignatureInfo {
        val qualifiedName = "${packageInfo.specifiedPackage}.${packageInfo.simpleName}"

        // All [KFunction] arguments
        // KFunction3<Type1, Type1, Type1, Type1> ==> <param1, param2, param3, return>
        val arguments: MutableList<KSTypeDefinition> = function.parameters
            .mapIndexed { index, parameter ->
                Pair(parameter.name?.asString() ?: "arg$index", parameter.type)
            }
            .toMutableList()

        // Skip function if parameter less then 2
        if (arguments.size < 2)
            throw CurryingExceptions.LessThanTwoParametersFunction(qualifiedName)

        // Add return type
        function.returnType?.let { returnType ->
            arguments.add(Pair("result", returnType))
        } ?: throw CurryingExceptions.UnresolvedFunctionReturnType(qualifiedName)

        // Process KFunction generic signature
        val extension = StringifyTypeDefinition("KFunction${arguments.size - 1}", "kotlin.reflect", arguments)

        // Jvm name for jvm platform to avoid type erase in jvm
        val signatureHash = arguments
            .joinToString(",") { it.second.typeQualifiedName() }
            .hashCode()
            .toUInt()
            .toString(16)
        val jvmNamePrefix = "${JVM_NAME_PREFIX}$qualifiedName.$signatureHash"
            .replace(".", "\\$")
        val jvmName = jvmNamePrefix + packageInfo.simpleName

        return FunctionSignatureInfo(listOf(), CURRYING_FUNCTION_NAME, extension, jvmName, arguments)
    }

    /**
     * Generates the function body template for a given list of parameters with proper indentation.
     *
     * Constructs nested lambda expressions for curried functions based on the input parameters.
     * Use the FUNCTION_BODY_TEMPLATE constant to format the output.
     *
     * @param list List of parameter pairs (name, type reference).
     * @return Formatted function body string with nested lambda expressions and proper indentation.
     * @see FUNCTION_BODY_TEMPLATE
     */
    private fun processFunctionBody(list: List<KSTypeDefinition>, qualified: Boolean = true): String {
        val source = list.takeLast(list.size - 1)
        val parameters = list.joinToString(", ") { it.first }
        val callSpacer = "\t".repeat(source.size)
        val call = "${callSpacer}this.invoke(${parameters})"

        return if (source.isEmpty()) {
            FUNCTION_BODY_TEMPLATE
                .loadTemplate("spacer", "")
                .loadTemplate("tail", "")
                .loadTemplate("content", call)
        } else {
            source.foldRightIndexed(call) { index, (name, type), acc ->
                val spacer = "\t".repeat(index)
                FUNCTION_BODY_TEMPLATE
                    .loadTemplate("spacer", spacer)
                    .loadTemplate("tail", "$name: ${type.typeQualifiedName(qualified)} ->")
                    .loadTemplate("content", acc)
            }
        }
    }

    /**
     * Retrieves the direct parent declaration path of a function declaration (from immediate parent to file level).
     *
     * Use cases include:
     * - Analyzing the context of functions nested within classes/interfaces
     * - Generating function signatures with full nesting paths
     * - Building code navigation based on class hierarchies
     *
     * @return A list of class/interface names from the immediate parent up to the file level,
     *         ordered from innermost to outermost.
     *         Example: For a function nested in `OuterClass.InnerClass`, returns `["InnerClass", "OuterClass"]`.
     *         Returns an empty list if the function has no parent declarations, or they cannot be resolved.
     */
    private fun KSFunctionDeclaration.directParentDeclarations(): List<String> {
        val directParent = parent ?: return emptyList()

        // Build a path from the direct parent node to the file
        val parentPath = buildList {
            var currentNode: KSNode? = directParent

            // Traverse to the file level
            while (currentNode != null && currentNode !is KSFile) {
                // Only handle class or interface declarations
                if (currentNode is KSClassDeclaration) {
                    add(currentNode.simpleName.asString())
                }
                currentNode = currentNode.parent
            }
        }
        return parentPath
    }

    /**
     * Validates that the function does not contain any unsupported modifiers.
     * Throws an exception if any modifiers from [UNSUPPORTED_FUNCTION_MODIFIER] are present.
     *
     * @throws CurryingExceptions.UnsupportedModifierWithFunction if unsupported modifiers are found.
     * @see UNSUPPORTED_FUNCTION_MODIFIER for the list of unsupported modifiers.
     */
    @Throws(CurryingExceptions::class)
    private fun KSFunctionDeclaration.modifierValidate() {
        if (isConstructor()) throw CurryingExceptions
            .UnsupportedConstructor(directParentDeclarations().joinToString("."))

        val unsupportedModifier = modifiers.filter(UNSUPPORTED_FUNCTION_MODIFIER::contains)
        if (unsupportedModifier.isEmpty()) return
        throw CurryingExceptions.UnsupportedModifierWithFunction(unsupportedModifier)
    }

    private fun List<KSTypeDefinition>.joinToMultiLineImport(separator: String = "\nimport ") =
        map { it.second.resolve().declaration.qualifiedName?.asString() }
            .distinct()
            .filterNotNull()
            .joinToString(separator)

    /**
     * Represents package information for a curried function.
     * Combines the base package, intermediate declarations, and function name.
     *
     * @property specifiedPackage The base package name (e.g., "com.example").
     * @property directNested The qualified names of parent declarations (e.g., "MY_CLASS").
     * @property simpleName The function's simple name (e.g., "myFunction").
     * @property packageName The fully qualified package name, including middleware (if any).
     */
    private data class PackageInfo(
        val specifiedPackage: String,
        val directNested: List<String>,
        val simpleName: String,
        val originPackage: String
    ) {
        val packageName: String
            get() {
                val collect = directNested.joinToString(".") {
                    it.uppercaseUpperWithUnderline()
                }
                return if (directNested.isNotEmpty()) "$specifiedPackage.$collect" else specifiedPackage
            }

        val fullOriginPackageName: String
            get() {
                val collect = directNested.joinToString(".")
                return if (directNested.isNotEmpty()) "$originPackage.$collect.$simpleName" else "$originPackage.$simpleName"
            }
    }

    /**
     * Holds information about a function's signature for currying transformation.
     * Used to generate type definitions and function declarations.
     *
     * @property modifiers List of function modifiers (e.g., public, internal).
     * @property name The function name.
     * @property extensionFor The receiver type for the curried function (KFunctionN).
     * @property jvmName The JVM-specific name to avoid type erasure issues.
     * @property arguments List of all parameters and the return type.
     */
    private data class FunctionSignatureInfo(
        val modifiers: List<Modifier>,
        val name: String,
        val extensionFor: StringifyTypeDefinition,
        val jvmName: String,
        val arguments: List<KSTypeDefinition>,
    ) {
        private companion object {
            const val SIGNATURE_TEMPLATE_WITHOUT_MODIFIER = "fun {{target}}.{{name}}({{parameters}}): {{return_type}}"
        }

        val parameters: List<KSTypeDefinition> = arguments.take(1)
        val returnTypeChain: List<KSTypeDefinition> = arguments.take(arguments.size - 1)

        /**
         * Returns the qualified KFunction type (e.g., kotlin.reflect.KFunction3<...>).
         * @param qualified Whether to include the package name.
         */
        fun getKFunction(qualified: Boolean) = extensionFor.getQualifier(qualified)

        /**
         * Generates the return type string for the curried function chain.
         * @param qualified Whether to use qualified type names.
         */
        fun getReturnTypeString(qualified: Boolean) = processFunctionTrailType(arguments, qualified)

        /**
         * Assembles the fully qualified function signature body.
         * Example: "fun kotlin.reflect.KFunction3<A, B, C, R>.currying(): (A) -> (B) -> (C) -> R"
         */
        fun assembleQualifiedFunctionBody(): String = SIGNATURE_TEMPLATE_WITHOUT_MODIFIER
            .loadTemplate("target", getKFunction(true))
            .loadTemplate("name", name)
            .loadTemplate("parameters", parameters.joinToString { it.typeDefinition(true) })
            .loadTemplate("return_type", getReturnTypeString(true))

        /**
         * Assembles the function signature using type aliases for brevity.
         * @param target The receiver type alias.
         * @param returned The return type alias.
         */
        fun assembleTypeAliasedBody(target: String, returned: String): String = SIGNATURE_TEMPLATE_WITHOUT_MODIFIER
            .loadTemplate("target", target)
            .loadTemplate("name", name)
            .loadTemplate("parameters", parameters.joinToString { it.typeDefinition(false) })
            .loadTemplate("return_type", returned)
    }

    /**
     * Represents a type definition with generics for code generation.
     * Used to construct KFunction signatures and other generic types.
     *
     * @param type The type name (e.g., "KFunction3").
     * @param packageName The package containing the type (e.g., "kotlin.reflect").
     * @param generics List of generic type parameters.
     */
    private data class StringifyTypeDefinition(
        private val type: String,
        private val packageName: String,
        private val generics: List<KSTypeDefinition>
    ) {
        /**
         * Assembles the generic type parameter list (e.g., "A, B, C, R").
         * @param qualified Whether to use qualified type names.
         */
        private fun assembleGenerics(qualified: Boolean): String =
            generics.joinToString(", ") { (_, type) -> type.typeQualifiedName(qualified) }

        /**
         * Returns the fully qualified type with generics (e.g., "kotlin.reflect.KFunction3<A, B, C, R>").
         * @param qualified Whether to include the package name.
         */
        fun getQualifier(qualified: Boolean = true): String =
            "${if (qualified) "$packageName." else ""}$type<${assembleGenerics(qualified)}>"

        /**
         * Returns the fully qualified type name without generics (e.g., "kotlin.reflect.KFunction3").
         */
        fun getQualifierNameWithoutGenerics() = "$packageName.$type"
    }
}

/**
 * Represents a type definition with a name and its KSP type reference.
 * Used throughout the currying processor to pair parameter/return names with their types.
 *
 * - First element: Name of the parameter or return value (e.g., "arg0", "result").
 * - Second element: KSP type reference for the parameter or return type.
 *
 * This typealias simplifies the handling of function signatures by associating names
 * with their respective type references in a consistent manner.
 */
private typealias KSTypeDefinition = Pair<String, KSTypeReference>
